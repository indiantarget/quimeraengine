= Multihilo con Boost C++ =

== Descripción ==

Boost es un conjunto de bibliotecas de software libre y revisión por pares preparadas para extender las capacidades del lenguaje de programación C++. Su licencia, de tipo BSD, permite que sea utilizada en cualquier tipo de proyectos, ya sean comerciales o no. Extraído de: Wikipedia

La librería que nos interese se llama Thread, y aparece bajo el namespace boost::thread. La librería originalmente fue escrito y diseñado por William E. Kempf y actualmente lo lleva Anthony Williams. La versión usada en ésta prueba de concepto es la 1.44.

La clase boost::thread es el responsable de lanzar y manejar los threads. Cada objeto boost::thread representa un hilo simple de ejecución. Los objetos boost::thread no es copiable. Usa los interfaces que le proporciona el S.O. para la creación y el manejo. 

== Creación de hilo == 

Un objteto boost::thread se crea pasandle una función o método que queremos ejecutarlo en un hilo. Existe varios método para ello que lo vamos a ver:
 * *`A Thread Function`* Estamos en el caso cuando queremos ejecutar una función en un hilo separado, para ello solamente es necesario pasar la función a lanzar en el constructor del hilo. 
{{{
void funcion_a_ejecutar()
{
}

boost::thread  func_thread (funcion_a_ejecutar);
}}}

 * *`Function with Arguments`* Si queremos pasar parámetros a la función que se ejecutará en un hilo aparte. Se consigue añadiendo los parámetros al constructor del hilo.
{{{
void funcion_a_ejecutar(param_1, param_2)
{
}

boost::thread func_thread (funcion_a_ejecutar, param_1, param_2);
}}}

 * *`Functor`* Un functor sirve para encapsular una función que será llamada en el hilo en un objeto. La clase define un metodo especial sobrecargando la función *`operator()`* que será llamada cuando el functor sea llamada.

{{{
class Worker
{
 ..... // El constructor
  
 void operator() ()
 {
   // Tareas a realizar por la función
 }
 
}

int main ()
{
  Worker w(); 

  boost::thread workerThread(w);
  .....
}
}}}
 * *`Object method `* Con frecuencia es conveniente definir un objeto con un método de instancia que se ejecuta en su propio hilo. En primer lugar, tenemos que especificar el método que vamos a utilizar y através del operador & para pasar la dirección del método. El segundo parámetro tiene que ser el puntero del objeto en si. Detrás vendrá todos los parámetros necesarios para invocar al método. 
 
{{{
  //Objeto Worker 
  Worker w(param1); 

  boost::thread workerThread (&Worker::metodo_a_invocar, &w, param1);
}}}

== Mecanismos de sincronización ==

Para evitar problemas de concurrencia en el acceso a recursos por parte de varios hilos de ejecución, se utilizan ciertos mecanismos:

 * *`Mutex`:* Es el típico candado de dos estados: abierto / cerrado.
 * *`FastMutex`:* Igual que Mutex, pero no recomendado para uso en funciones recursivas.
 * *`Semaphore`:* Implementa un semáforo, que limita la cantidad de hilos que acceden a una zona de código determinada. Cada vez que se llama a "wait", se decrementa un contador interno y cuando se llama a "set" se incrementa. Si el contador es inferior a cero, el hilo espera a que vuelva a ser positivo.
 * *`ScopedMutex`:* Se usa en conjunto con un Mutex. Cuando se crea, bloquea el mutex y cuando se destruye lo desbloquea. Es ideal debido a que siempre liberará el mutex, aunque ocurra un error en la función. Se deduce que en la gran mayoría de los casos se declarará como variable local.
 * *`Condition`:* Dado un conjunto de hilos paralelos, es posible su sincronización de la siguiente manera: Un hilo crea un Mutex y lo introduce en la Condition (que utiliza una pila en su interior) mediante el método "wait"; con esto el mutex queda bloqueado y espera a que otro hilo lo desbloquee; cuando otro hilo llama al método "sygnal", el último mutex introducido se desbloquea, y el hilo que lo declaró puede continuar. Es posible desbloquear todos los mutex de la pila con el método "broadcast".

== Gestión de hilos ==

 * *`ThreadPool`:* Se trata de un depósito de instancias de Thread ya alojadas en memoria, al cual se le pide la ejecución de objetos Runnable y derivados, de manera que, internamente, utiliza el primer Thread que encuentre libre para lanzar el hilo de ejecución.

== Métodos estáticos de hilo ==

La clase Thread expone varios métodos estáticos que nos sirven para manipular el hilo desde del cual los llamamos:

 * *`current`:* Devuelve un Thread que encapsula el hilo actual.
 * *`sleep`:* Pausa la ejecución del hilo actual durante un tiempo determinado.
 * *`yield`:* Permite que la CPU en uso por el hilo actual sea usada por otros hilos.
 * *`currentTid`:* El identificador otorgado por el sistema operativo al hilo actual.

== Clases de ayuda ==

 * *`ErrorHandler`:* Actúa como un repositorio común de excepciones al que enviar información de errores ocurridos en todos los hilos (las excepciones ocurridas en un hilo no saltan al principal, el hilo muere y nada más), de manera que pueda ser gestionado por el hilo principal o por cualquier otro.

*Nota:* Todas las clases descritas residen en el namespace "Poco".

== Código fuente de la Prueba de concepto ==
[https://quimeraengine.googlecode.com/svn/team/poc/Task%208%20-%20Multithreading]

== Enlaces de interés ==
 * [http://www.boost.org/ Web oficial de BOOST]
 * [http://www.boost.org/doc/libs/1_44_0/doc/html/thread.html Documentación de la sección de Threading]